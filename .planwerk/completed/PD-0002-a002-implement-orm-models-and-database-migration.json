{
  "feature_id": "PD-0002",
  "title": "A002: Implement ORM models and database migration",
  "slug": "a002-implement-orm-models-and-database-migration",
  "status": "completed",
  "phase": "awaiting_external_review",
  "summary": "",
  "description": "User and StatusUpdate models with all fields per data model, relationships. Alembic async config, initial migration.",
  "stories": [
    {
      "title": "Developer can define User records in the database",
      "role": "developer",
      "want": "a User SQLAlchemy ORM model with all fields from the data model specification",
      "so_that": "user data can be persisted and queried using the async SQLAlchemy session",
      "criteria": [
        "User model has columns: id (UUID PK), username (VARCHAR 50, unique), display_name (VARCHAR 100), email (VARCHAR 255, unique), password_hash (VARCHAR 255), avatar_url (VARCHAR 500, nullable), xp (INTEGER, default 0), current_streak (INTEGER, default 0), longest_streak (INTEGER, default 0), last_post_date (DATE, nullable), created_at (TIMESTAMP with timezone, server default utcnow)",
        "User model uses __tablename__ = 'users'",
        "User model inherits from Base (DeclarativeBase) defined in app.database",
        "User.id uses uuid4 as default for new records"
      ]
    },
    {
      "title": "Developer can define StatusUpdate records linked to a User",
      "role": "developer",
      "want": "a StatusUpdate SQLAlchemy ORM model with a foreign key to User and all fields from the data model specification",
      "so_that": "status updates can be persisted, queried, and associated with their author",
      "criteria": [
        "StatusUpdate model has columns: id (UUID PK), user_id (UUID FK to users.id, not null), message (TEXT), category (VARCHAR 20), created_at (TIMESTAMP with timezone, server default utcnow)",
        "StatusUpdate model uses __tablename__ = 'status_updates'",
        "StatusUpdate model inherits from Base",
        "StatusUpdate.user_id has a ForeignKey constraint referencing users.id"
      ]
    },
    {
      "title": "Developer can navigate User-StatusUpdate relationship via ORM",
      "role": "developer",
      "want": "SQLAlchemy relationship() attributes on both User and StatusUpdate models",
      "so_that": "I can traverse from a user to their status updates and vice versa without manual joins",
      "criteria": [
        "User has a 'status_updates' relationship attribute returning a list of StatusUpdate instances",
        "StatusUpdate has a 'user' relationship attribute returning the associated User instance",
        "relationship uses back_populates for bidirectional navigation",
        "Relationship uses lazy='selectin' or similar async-compatible loading strategy"
      ]
    },
    {
      "title": "Developer can run Alembic migrations against the async PostgreSQL database",
      "role": "developer",
      "want": "Alembic configured for async SQLAlchemy with a migration for the initial User and StatusUpdate tables",
      "so_that": "database schema changes are tracked in version control and applied consistently across environments",
      "criteria": [
        "alembic.ini exists in backend/ with sqlalchemy.url placeholder (overridden by env.py)",
        "alembic/env.py uses async engine from app.database and imports Base.metadata for autogenerate",
        "Running 'alembic upgrade head' creates both users and status_updates tables",
        "Running 'alembic downgrade base' drops both tables"
      ]
    },
    {
      "title": "Developer can import all models from a single entry point",
      "role": "developer",
      "want": "app/models/__init__.py to re-export User and StatusUpdate so that imports are consistent",
      "so_that": "downstream code can use 'from app.models import User, StatusUpdate' instead of importing from individual modules",
      "criteria": [
        "app/models/__init__.py exports User and StatusUpdate",
        "__all__ is defined listing both model classes",
        "Importing from app.models triggers model registration with Base.metadata"
      ]
    },
    {
      "title": "Database constraints enforce data integrity at the schema level",
      "role": "system",
      "want": "unique constraints, not-null constraints, and foreign key constraints defined on the ORM models",
      "so_that": "invalid data is rejected at the database level even if application validation is bypassed",
      "criteria": [
        "username column has a unique constraint",
        "email column has a unique constraint",
        "user_id FK on status_updates is NOT NULL",
        "ForeignKey on user_id references users.id correctly",
        "id columns use server-side UUID generation or Python-side uuid4 default"
      ]
    }
  ],
  "requirements": [
    {
      "id": "REQ-001",
      "description": "The User model SHALL define all columns matching the data model specification in README.md",
      "priority": "SHALL",
      "rationale": "All downstream features (auth, profiles, gamification) depend on a complete User model",
      "scenarios": [
        {
          "name": "User model has all specified columns",
          "when": "the User model class is inspected via SQLAlchemy introspection",
          "then": "it has columns: id, username, display_name, email, password_hash, avatar_url, xp, current_streak, longest_streak, last_post_date, created_at",
          "and_then": [
            "column count matches the specification exactly (11 columns)"
          ]
        },
        {
          "name": "User model column types match specification",
          "when": "the User model columns are inspected for types",
          "then": "id is UUID, username is String(50), display_name is String(100), email is String(255), password_hash is String(255), avatar_url is String(500), xp is Integer, current_streak is Integer, longest_streak is Integer, last_post_date is Date, created_at is DateTime with timezone",
          "and_then": []
        },
        {
          "name": "User model defaults match specification",
          "when": "a User instance is created with only required fields",
          "then": "xp defaults to 0, current_streak defaults to 0, longest_streak defaults to 0, avatar_url defaults to None, last_post_date defaults to None",
          "and_then": [
            "created_at is set automatically via server default"
          ]
        }
      ]
    },
    {
      "id": "REQ-002",
      "description": "The StatusUpdate model SHALL define all columns matching the data model specification in README.md",
      "priority": "SHALL",
      "rationale": "The status update is the core domain entity of the application",
      "scenarios": [
        {
          "name": "StatusUpdate model has all specified columns",
          "when": "the StatusUpdate model class is inspected",
          "then": "it has columns: id, user_id, message, category, created_at",
          "and_then": [
            "column count matches the specification exactly (5 columns)"
          ]
        },
        {
          "name": "StatusUpdate model column types match specification",
          "when": "the StatusUpdate model columns are inspected for types",
          "then": "id is UUID, user_id is UUID, message is Text, category is String(20), created_at is DateTime with timezone",
          "and_then": []
        },
        {
          "name": "StatusUpdate created_at has server default",
          "when": "a StatusUpdate row is inserted without specifying created_at",
          "then": "created_at is automatically set to the current UTC timestamp by the database server",
          "and_then": []
        }
      ]
    },
    {
      "id": "REQ-003",
      "description": "The User model SHALL enforce unique constraints on username and email columns",
      "priority": "SHALL",
      "rationale": "Username and email uniqueness is required for authentication and user identification",
      "scenarios": [
        {
          "name": "Username uniqueness enforced",
          "when": "the User model's username column is inspected",
          "then": "it has unique=True",
          "and_then": [
            "the generated migration includes a unique constraint on username"
          ]
        },
        {
          "name": "Email uniqueness enforced",
          "when": "the User model's email column is inspected",
          "then": "it has unique=True",
          "and_then": [
            "the generated migration includes a unique constraint on email"
          ]
        },
        {
          "name": "Non-nullable required columns enforced",
          "when": "the User model columns are inspected",
          "then": "username, display_name, email, password_hash are NOT nullable",
          "and_then": []
        }
      ]
    },
    {
      "id": "REQ-004",
      "description": "The StatusUpdate model SHALL have a foreign key relationship to the User model",
      "priority": "SHALL",
      "rationale": "Each status update must be associated with exactly one user for ownership and attribution",
      "scenarios": [
        {
          "name": "Foreign key references users table",
          "when": "the StatusUpdate.user_id column is inspected",
          "then": "it has a ForeignKey constraint referencing users.id",
          "and_then": [
            "user_id is NOT nullable"
          ]
        },
        {
          "name": "Bidirectional relationship exists",
          "when": "User and StatusUpdate relationship attributes are inspected",
          "then": "User has 'status_updates' relationship and StatusUpdate has 'user' relationship",
          "and_then": [
            "both use back_populates for bidirectional navigation"
          ]
        },
        {
          "name": "Relationship loading is async-compatible",
          "when": "the relationship is configured",
          "then": "it does not use default lazy loading (which fails with async sessions)",
          "and_then": [
            "relationship uses lazy='selectin' or similar async-compatible strategy"
          ]
        }
      ]
    },
    {
      "id": "REQ-005",
      "description": "Alembic SHALL be configured for async SQLAlchemy with the project's database engine",
      "priority": "SHALL",
      "rationale": "Database migrations must use the same async engine as the application to ensure consistency",
      "scenarios": [
        {
          "name": "Alembic env.py uses async engine",
          "when": "alembic/env.py is inspected",
          "then": "it imports the async engine from app.database and uses run_async_migrations",
          "and_then": [
            "it imports Base.metadata from app.database for autogenerate support"
          ]
        },
        {
          "name": "Alembic reads DATABASE_URL from app config",
          "when": "Alembic runs a migration",
          "then": "it uses the DATABASE_URL from app.config.settings, not from alembic.ini",
          "and_then": [
            "the sqlalchemy.url in alembic.ini is a placeholder only"
          ]
        },
        {
          "name": "alembic.ini configured correctly",
          "when": "alembic.ini is inspected",
          "then": "script_location points to alembic/, file_template includes timestamp for ordering",
          "and_then": []
        }
      ]
    },
    {
      "id": "REQ-006",
      "description": "An initial Alembic migration SHALL create both the users and status_updates tables",
      "priority": "SHALL",
      "rationale": "The migration must be the single source of truth for the initial database schema",
      "scenarios": [
        {
          "name": "Migration creates users table",
          "when": "the initial migration's upgrade() is inspected",
          "then": "it creates a 'users' table with all columns matching the User model",
          "and_then": [
            "unique constraints on username and email are included"
          ]
        },
        {
          "name": "Migration creates status_updates table",
          "when": "the initial migration's upgrade() is inspected",
          "then": "it creates a 'status_updates' table with all columns matching the StatusUpdate model",
          "and_then": [
            "foreign key on user_id referencing users.id is included"
          ]
        },
        {
          "name": "Migration is reversible",
          "when": "the initial migration's downgrade() is inspected",
          "then": "it drops both status_updates and users tables (status_updates first due to FK dependency)",
          "and_then": []
        }
      ]
    },
    {
      "id": "REQ-007",
      "description": "The models package SHALL export both User and StatusUpdate from app.models",
      "priority": "SHALL",
      "rationale": "A consistent import path simplifies downstream code and ensures models are registered with Base.metadata",
      "scenarios": [
        {
          "name": "Models importable from package",
          "when": "from app.models import User, StatusUpdate is executed",
          "then": "both classes are successfully imported",
          "and_then": [
            "both classes are registered in Base.metadata.tables"
          ]
        },
        {
          "name": "__all__ defined",
          "when": "app/models/__init__.py is inspected",
          "then": "__all__ lists both 'User' and 'StatusUpdate'",
          "and_then": []
        },
        {
          "name": "Models inherit from Base",
          "when": "User and StatusUpdate are inspected",
          "then": "both are subclasses of Base from app.database",
          "and_then": []
        }
      ]
    },
    {
      "id": "REQ-008",
      "description": "The models SHALL use UUID primary keys with Python-side uuid4 default",
      "priority": "SHALL",
      "rationale": "UUID primary keys support distributed systems and prevent enumeration attacks",
      "scenarios": [
        {
          "name": "User.id is UUID primary key",
          "when": "User.id column is inspected",
          "then": "the column type is sa.Uuid and it is a primary key",
          "and_then": [
            "default uses uuid.uuid4"
          ]
        },
        {
          "name": "StatusUpdate.id is UUID primary key",
          "when": "StatusUpdate.id column is inspected",
          "then": "the column type is sa.Uuid and it is a primary key",
          "and_then": [
            "default uses uuid.uuid4"
          ]
        },
        {
          "name": "UUID values are unique across instances",
          "when": "two model instances are created without explicit IDs",
          "then": "each receives a distinct UUID",
          "and_then": []
        }
      ]
    }
  ],
  "tasks": [
    {
      "id": "1.1",
      "title": "Create User ORM model in app/models/user.py with all columns, constraints, and relationship (REQ-001, REQ-003, REQ-008)",
      "description": "Create backend/app/models/user.py with class User(Base): __tablename__ = 'users'. Columns: id (Mapped[uuid.UUID], mapped_column(sa.Uuid, primary_key=True, default=uuid.uuid4)), username (Mapped[str], mapped_column(sa.String(50), unique=True, nullable=False)), display_name (Mapped[str], mapped_column(sa.String(100), nullable=False)), email (Mapped[str], mapped_column(sa.String(255), unique=True, nullable=False)), password_hash (Mapped[str], mapped_column(sa.String(255), nullable=False)), avatar_url (Mapped[str | None], mapped_column(sa.String(500), nullable=True)), xp (Mapped[int], mapped_column(sa.Integer, default=0, server_default='0')), current_streak (Mapped[int], mapped_column(sa.Integer, default=0, server_default='0')), longest_streak (Mapped[int], mapped_column(sa.Integer, default=0, server_default='0')), last_post_date (Mapped[datetime.date | None], mapped_column(sa.Date, nullable=True)), created_at (Mapped[datetime.datetime], mapped_column(sa.DateTime(timezone=True), server_default=sa.func.now())). Add relationship: status_updates: Mapped[list['StatusUpdate']] = relationship(back_populates='user', lazy='selectin'). Import Base from app.database.",
      "level": 1,
      "estimate_minutes": 20,
      "status": "done",
      "requirements": [
        "REQ-001",
        "REQ-003",
        "REQ-008"
      ]
    },
    {
      "id": "1.2",
      "title": "Create StatusUpdate ORM model in app/models/status.py with all columns, FK, and relationship (REQ-002, REQ-004, REQ-008)",
      "description": "Create backend/app/models/status.py with class StatusUpdate(Base): __tablename__ = 'status_updates'. Columns: id (Mapped[uuid.UUID], mapped_column(sa.Uuid, primary_key=True, default=uuid.uuid4)), user_id (Mapped[uuid.UUID], mapped_column(sa.Uuid, sa.ForeignKey('users.id'), nullable=False)), message (Mapped[str], mapped_column(sa.Text, nullable=False)), category (Mapped[str], mapped_column(sa.String(20), nullable=False)), created_at (Mapped[datetime.datetime], mapped_column(sa.DateTime(timezone=True), server_default=sa.func.now())). Add relationship: user: Mapped['User'] = relationship(back_populates='status_updates', lazy='selectin'). Import Base from app.database.",
      "level": 1,
      "estimate_minutes": 15,
      "status": "done",
      "requirements": [
        "REQ-002",
        "REQ-004",
        "REQ-008"
      ]
    },
    {
      "id": "1.3",
      "title": "Update app/models/__init__.py to export User and StatusUpdate with __all__ (REQ-007)",
      "description": "Edit backend/app/models/__init__.py to import User from app.models.user and StatusUpdate from app.models.status. Define __all__ = ['User', 'StatusUpdate']. This ensures both models are registered with Base.metadata when the package is imported.",
      "level": 1,
      "estimate_minutes": 5,
      "status": "done",
      "requirements": [
        "REQ-007"
      ]
    },
    {
      "id": "2.1",
      "title": "Write unit tests for User model column definitions, types, and constraints (REQ-001, REQ-003, REQ-008)",
      "description": "Create backend/tests/unit/test_models.py. Use SQLAlchemy introspection (inspect(User) or User.__table__.columns) to verify: (1) User has exactly 11 columns matching spec (id, username, display_name, email, password_hash, avatar_url, xp, current_streak, longest_streak, last_post_date, created_at). (2) Column types match spec (String lengths, Integer, Date, DateTime timezone, Uuid). (3) username and email have unique=True. (4) username, display_name, email, password_hash are not nullable. (5) avatar_url, last_post_date are nullable. (6) xp, current_streak, longest_streak have server_default='0'. (7) id is primary key with uuid4 default. (8) User.__tablename__ == 'users'. (9) User inherits from Base. Follow existing test style from test_database.py (class-per-scenario, descriptive docstrings).",
      "level": 2,
      "estimate_minutes": 25,
      "status": "done",
      "requirements": [
        "REQ-001",
        "REQ-003",
        "REQ-008"
      ]
    },
    {
      "id": "2.2",
      "title": "Write unit tests for StatusUpdate model column definitions, FK, relationship, and types (REQ-002, REQ-004, REQ-008)",
      "description": "Add tests to backend/tests/unit/test_models.py for StatusUpdate: (1) StatusUpdate has exactly 5 columns (id, user_id, message, category, created_at). (2) Column types match spec (Uuid, Text, String(20), DateTime timezone). (3) user_id has ForeignKey to 'users.id'. (4) user_id is not nullable. (5) id is primary key with uuid4 default. (6) StatusUpdate.__tablename__ == 'status_updates'. (7) StatusUpdate inherits from Base. (8) StatusUpdate has 'user' relationship attribute. (9) User has 'status_updates' relationship attribute. (10) Both models are importable from app.models.",
      "level": 2,
      "estimate_minutes": 20,
      "status": "done",
      "requirements": [
        "REQ-002",
        "REQ-004",
        "REQ-008"
      ]
    },
    {
      "id": "3.1",
      "title": "Configure Alembic for async SQLAlchemy: create alembic.ini and alembic/env.py (REQ-005)",
      "description": "Create backend/alembic.ini with: [alembic] script_location = alembic, sqlalchemy.url = driver://user:pass@localhost/dbname (placeholder, overridden in env.py), file_template = %%(year)d_%%(month).2d_%%(day).2d_%%(hour).2d%%(minute).2d-%%(rev)s_%%(slug)s. Create backend/alembic/ directory with env.py that: imports asyncio, imports create_async_engine from sqlalchemy.ext.asyncio, imports settings from app.config, imports Base from app.database, imports all models via 'from app.models import User, StatusUpdate' (to register metadata), sets target_metadata = Base.metadata, defines run_migrations_offline() using settings.DATABASE_URL, defines run_migrations_online() using an async engine created from settings.DATABASE_URL with connectable.connect() in async context, calls asyncio.run() from run_migrations_online. Also create alembic/script.py.mako template (standard Alembic template).",
      "level": 3,
      "estimate_minutes": 25,
      "status": "done",
      "requirements": [
        "REQ-005"
      ]
    },
    {
      "id": "3.2",
      "title": "Create initial Alembic migration for users and status_updates tables (REQ-006)",
      "description": "Manually create backend/alembic/versions/ directory and write the initial migration file. The migration's upgrade() must: create 'users' table with all 11 columns (correct types, constraints, server defaults), then create 'status_updates' table with all 5 columns (FK to users.id, correct types). The downgrade() must: drop 'status_updates' first (FK dependency), then drop 'users'. Use op.create_table() with sa.Column definitions matching the ORM models exactly. Include unique constraints on users.username and users.email. Use sa.Uuid for UUID columns, sa.func.now() for timestamp server defaults. Revision ID should be a short hex string.",
      "level": 3,
      "estimate_minutes": 25,
      "status": "done",
      "requirements": [
        "REQ-006"
      ]
    },
    {
      "id": "4.1",
      "title": "Write unit tests for Alembic configuration and migration structure (REQ-005, REQ-006)",
      "description": "Add tests to backend/tests/unit/test_models.py (or create test_migrations.py): (1) alembic.ini exists and has script_location = alembic. (2) alembic/env.py exists. (3) At least one migration file exists in alembic/versions/. (4) The migration file contains op.create_table('users') and op.create_table('status_updates'). (5) The migration's downgrade drops status_updates before users. These are structural/file-based tests that verify the migration was created correctly without running against a database.",
      "level": 4,
      "estimate_minutes": 20,
      "status": "done",
      "requirements": [
        "REQ-005",
        "REQ-006"
      ]
    },
    {
      "id": "5.1",
      "title": "Write Reference documentation for User and StatusUpdate models and Alembic configuration",
      "description": "Create docs/reference/backend/models.md documenting: (1) User model — full column table with field name, SQLAlchemy type, Python type, constraints, defaults, and description for each. (2) StatusUpdate model — same format. (3) Relationships section showing User 1:N StatusUpdate with back_populates. (4) Import examples: 'from app.models import User, StatusUpdate'. (5) Alembic configuration section: how env.py reads DATABASE_URL from settings, how to run migrations ('alembic upgrade head', 'alembic downgrade base'), migration file naming convention. Follow Diataxis reference style (information-oriented).",
      "level": 5,
      "estimate_minutes": 20,
      "status": "done",
      "requirements": [
        "REQ-001",
        "REQ-002",
        "REQ-005"
      ]
    }
  ],
  "test_specifications": [
    {
      "test_file": "backend/tests/unit/test_models.py",
      "test_function": "test_user_has_all_specified_columns",
      "story": "Developer can define User records in the database",
      "expected": "User.__table__.columns contains exactly 11 columns: id, username, display_name, email, password_hash, avatar_url, xp, current_streak, longest_streak, last_post_date, created_at",
      "requirement_id": "REQ-001"
    },
    {
      "test_file": "backend/tests/unit/test_models.py",
      "test_function": "test_user_column_types_match_spec",
      "story": "Developer can define User records in the database",
      "expected": "Each column's type matches the data model: String(50) for username, String(100) for display_name, String(255) for email and password_hash, String(500) for avatar_url, Integer for xp/streaks, Date for last_post_date, DateTime(timezone=True) for created_at",
      "requirement_id": "REQ-001"
    },
    {
      "test_file": "backend/tests/unit/test_models.py",
      "test_function": "test_user_username_unique_constraint",
      "story": "Database constraints enforce data integrity at the schema level",
      "expected": "User.__table__.columns['username'].unique is True",
      "requirement_id": "REQ-003"
    },
    {
      "test_file": "backend/tests/unit/test_models.py",
      "test_function": "test_user_email_unique_constraint",
      "story": "Database constraints enforce data integrity at the schema level",
      "expected": "User.__table__.columns['email'].unique is True",
      "requirement_id": "REQ-003"
    },
    {
      "test_file": "backend/tests/unit/test_models.py",
      "test_function": "test_user_id_is_uuid_primary_key",
      "story": "Developer can define User records in the database",
      "expected": "User.id column is Uuid type and primary_key=True",
      "requirement_id": "REQ-008"
    },
    {
      "test_file": "backend/tests/unit/test_models.py",
      "test_function": "test_user_integer_defaults",
      "story": "Developer can define User records in the database",
      "expected": "xp, current_streak, longest_streak columns have server_default='0'",
      "requirement_id": "REQ-001"
    },
    {
      "test_file": "backend/tests/unit/test_models.py",
      "test_function": "test_user_tablename",
      "story": "Developer can define User records in the database",
      "expected": "User.__tablename__ == 'users'",
      "requirement_id": "REQ-001"
    },
    {
      "test_file": "backend/tests/unit/test_models.py",
      "test_function": "test_user_inherits_from_base",
      "story": "Developer can define User records in the database",
      "expected": "issubclass(User, Base) is True",
      "requirement_id": "REQ-007"
    },
    {
      "test_file": "backend/tests/unit/test_models.py",
      "test_function": "test_status_update_has_all_specified_columns",
      "story": "Developer can define StatusUpdate records linked to a User",
      "expected": "StatusUpdate.__table__.columns contains exactly 5 columns: id, user_id, message, category, created_at",
      "requirement_id": "REQ-002"
    },
    {
      "test_file": "backend/tests/unit/test_models.py",
      "test_function": "test_status_update_column_types_match_spec",
      "story": "Developer can define StatusUpdate records linked to a User",
      "expected": "Column types: Uuid for id/user_id, Text for message, String(20) for category, DateTime(timezone=True) for created_at",
      "requirement_id": "REQ-002"
    },
    {
      "test_file": "backend/tests/unit/test_models.py",
      "test_function": "test_status_update_user_id_foreign_key",
      "story": "Developer can define StatusUpdate records linked to a User",
      "expected": "StatusUpdate.user_id has ForeignKey referencing 'users.id'",
      "requirement_id": "REQ-004"
    },
    {
      "test_file": "backend/tests/unit/test_models.py",
      "test_function": "test_status_update_user_id_not_nullable",
      "story": "Developer can define StatusUpdate records linked to a User",
      "expected": "StatusUpdate.__table__.columns['user_id'].nullable is False",
      "requirement_id": "REQ-004"
    },
    {
      "test_file": "backend/tests/unit/test_models.py",
      "test_function": "test_bidirectional_relationship",
      "story": "Developer can navigate User-StatusUpdate relationship via ORM",
      "expected": "User has 'status_updates' relationship attr and StatusUpdate has 'user' relationship attr",
      "requirement_id": "REQ-004"
    },
    {
      "test_file": "backend/tests/unit/test_models.py",
      "test_function": "test_models_importable_from_package",
      "story": "Developer can import all models from a single entry point",
      "expected": "'from app.models import User, StatusUpdate' succeeds and both are registered in Base.metadata",
      "requirement_id": "REQ-007"
    },
    {
      "test_file": "backend/tests/unit/test_models.py",
      "test_function": "test_models_all_defined",
      "story": "Developer can import all models from a single entry point",
      "expected": "app.models.__all__ contains 'User' and 'StatusUpdate'",
      "requirement_id": "REQ-007"
    },
    {
      "test_file": "backend/tests/unit/test_models.py",
      "test_function": "test_alembic_ini_exists",
      "story": "Developer can run Alembic migrations against the async PostgreSQL database",
      "expected": "backend/alembic.ini file exists with script_location = alembic",
      "requirement_id": "REQ-005"
    },
    {
      "test_file": "backend/tests/unit/test_models.py",
      "test_function": "test_migration_file_exists",
      "story": "Developer can run Alembic migrations against the async PostgreSQL database",
      "expected": "At least one .py file exists in backend/alembic/versions/",
      "requirement_id": "REQ-006"
    },
    {
      "test_file": "backend/tests/unit/test_models.py",
      "test_function": "test_migration_creates_both_tables",
      "story": "Developer can run Alembic migrations against the async PostgreSQL database",
      "expected": "Migration file source contains op.create_table for both 'users' and 'status_updates'",
      "requirement_id": "REQ-006"
    }
  ],
  "affected_files": [],
  "similar_patterns": [],
  "review_criteria": [
    "All SHALL requirements (REQ-001 through REQ-008) have corresponding passing tests",
    "`uv run pytest tests/unit/test_models.py -v` passes with zero failures",
    "`uv run ruff check .` in backend/ exits with code 0",
    "`uv run mypy app/models/` passes with no type errors under strict mode",
    "User model has exactly 11 columns with types, constraints, and defaults matching README data model",
    "StatusUpdate model has exactly 5 columns with FK to users.id and correct types",
    "Bidirectional relationship between User and StatusUpdate uses back_populates and async-compatible lazy loading",
    "alembic/env.py uses async engine from app.database and imports Base.metadata",
    "Initial migration creates users table before status_updates (FK dependency order) and downgrade drops in reverse order",
    "app/models/__init__.py exports User and StatusUpdate with __all__ defined"
  ],
  "implementation_notes": "This feature creates the ORM models and Alembic migration that all subsequent features build upon. NO Pydantic schemas (PD-0003), NO services, NO API endpoints.\n\nArchitectural decisions:\n- Use SQLAlchemy 2.0 Mapped[] annotation style (not legacy Column()) for type safety with mypy strict mode\n- Use sa.Uuid (SQLAlchemy 2.0 native UUID type) instead of deprecated postgresql.UUID for cross-DB compatibility\n- Use server_default for xp/streak integers (server_default='0') so defaults are applied even in raw SQL\n- Use server_default=sa.func.now() for created_at so timestamps are consistent with DB server time\n- Use lazy='selectin' on relationships to avoid async lazy-loading issues (default 'select' raises errors with async sessions)\n- Import models in alembic/env.py to ensure Base.metadata knows about all tables for autogenerate\n\nKey files to follow patterns from:\n- backend/app/database.py: Base class to inherit from, engine/session setup\n- backend/tests/unit/test_database.py: test style (class-per-scenario, descriptive docstrings, structural tests)\n- backend/pyproject.toml: mypy strict mode requires Mapped[] annotations\n\nPotential pitfalls:\n- Forgetting to import models in alembic/env.py causes autogenerate to produce empty migrations\n- Using default lazy='select' with async sessions raises MissingGreenlet errors — must use 'selectin' or 'raise'\n- mypy strict mode requires explicit Mapped[] type annotations on all columns — Column() without Mapped[] will fail typecheck\n- Migration downgrade must drop status_updates before users due to FK constraint\n- The existing test conftest.py sets JWT_SECRET at module level — model tests should not need this but imports may trigger it via app.database -> app.config chain",
  "status_history": {
    "draft": {
      "github_account": "berendt",
      "timestamp": "2026-02-24T19:10:35.694981"
    },
    "preparing": {
      "github_account": "berendt",
      "timestamp": "2026-02-28T21:40:57.248836"
    },
    "prepared": {
      "github_account": "berendt",
      "timestamp": "2026-02-28T21:44:30.059307"
    },
    "processing": {
      "github_account": "berendt",
      "timestamp": "2026-02-28T21:46:02.083962"
    },
    "completed": {
      "github_account": "berendt",
      "timestamp": "2026-02-28T22:28:46.293065"
    }
  },
  "github_pr": "https://github.com/Planwerk/demo/pull/13",
  "pr_number": 13,
  "execution_history": [
    {
      "run_id": "6e245abd-39a0-49f5-ad50-a3c14c367121",
      "timestamp": "2026-02-28T21:44:30.059334",
      "total_duration": 209.92970061302185,
      "status": "completed",
      "timings": [
        {
          "name": "prepare",
          "duration": 209.92970061302185,
          "type": "prepare",
          "status": "done"
        }
      ]
    },
    {
      "run_id": "761fe42b-839e-4caf-bdee-b2de651b6a15",
      "timestamp": "2026-02-28T22:11:37.432721",
      "total_duration": 1409.9463300704956,
      "status": "completed",
      "timings": [
        {
          "name": "Level 1 (3 tasks)",
          "duration": 300.00235199928284,
          "type": "level",
          "status": "done"
        },
        {
          "name": "Level 2 (2 tasks)",
          "duration": 135.18469047546387,
          "type": "level",
          "status": "done"
        },
        {
          "name": "Level 3 (2 tasks)",
          "duration": 228.15678358078003,
          "type": "level",
          "status": "done"
        },
        {
          "name": "Level 4 (1 tasks)",
          "duration": 88.49598693847656,
          "type": "level",
          "status": "done"
        },
        {
          "name": "Level 5 (1 tasks)",
          "duration": 66.04063415527344,
          "type": "level",
          "status": "done"
        },
        {
          "name": "[PD-0002] Code Review",
          "duration": 225.55491948127747,
          "type": "review",
          "status": "done"
        },
        {
          "name": "[PD-0002] Improvements",
          "duration": 122.48661804199219,
          "type": "improve",
          "status": "done"
        },
        {
          "name": "[PD-0002] Simplify",
          "duration": 244.02434539794922,
          "type": "simplify",
          "status": "done"
        }
      ]
    }
  ]
}