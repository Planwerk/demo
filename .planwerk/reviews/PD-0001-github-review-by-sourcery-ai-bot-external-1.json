{
  "feature_id": "PD-0001",
  "title": "GitHub Review by sourcery-ai[bot]",
  "summary": "Hey - I've found 2 issues, and left some high level feedback:\n\n- In `Settings.cors_origins_list`, returning `[\"\"]` when `CORS_ORIGINS` is an empty string can lead to a bogus allowed origin being configured; consider returning an empty list instead for the empty/whitespace-only case.\n- The `client` fixture in `test_health.py` creates an `httpx.AsyncClient` but never closes it; turning this into an async fixture that `await client.aclose()` in teardown will avoid potential resource warnings and better mirror real lifecycle usage.\n- As the project grows, keeping the router definition in `app/main.py` may become unwieldy; you might want to move the router (and the health endpoint) into the `app.api` package and have `main.py` just assemble the app and include routers.\n\n<details>\n<summary>Prompt for AI Agents</summary>\n\n~~~markdown\nPlease address the comments from this code review:\n\n## Overall Comments\n- In `Settings.cors_origins_list`, returning `[\"\"]` when `CORS_ORIGINS` is an empty string can lead to a bogus allowed origin being configured; consider returning an empty list instead for the empty/whitespace-only case.\n- The `client` fixture in `test_health.py` creates an `httpx.AsyncClient` but never closes it; turning this into an async fixture that `await client.aclose()` in teardown will avoid potential resource warnings and better mirror real lifecycle usage.\n- As the project grows, keeping the router definition in `app/main.py` may become unwieldy; you might want to move the router (and the health endpoint) into the `app.api` package and have `main.py` just assemble the app and include routers.\n\n## Individual Comments\n\n### Comment 1\n<location path=\"backend/tests/unit/test_health.py\" line_range=\"30-40\" />\n<code_context>\n+    assert \"authorization\" not in resp.request.headers\n+\n+\n+async def test_cors_headers_present_for_allowed_origin(client: httpx.AsyncClient) -> None:\n+    \"\"\"Response includes access-control-allow-origin for the default allowed origin.\"\"\"\n+    resp = await client.options(\n+        \"/api/v1/health\",\n+        headers={\n+            \"origin\": \"http://localhost:3000\",\n+            \"access-control-request-method\": \"GET\",\n+        },\n+    )\n+    assert resp.headers.get(\"access-control-allow-origin\") == \"http://localhost:3000\"\n+    assert resp.headers.get(\"access-control-allow-credentials\") == \"true\"\n+\n+\n</code_context>\n<issue_to_address>\n**suggestion (testing):** Add assertions on the CORS preflight response status code\n\nRight now this only checks the CORS headers. To better validate the preflight behavior, also assert the response status (FastAPI/Starlette typically returns 200 or 204), for example:\n\n```python\nassert resp.status_code in {200, 204}\n```\n\nThis would prevent a misconfigured middleware that returns an error status from still passing the test based solely on headers.\n\n```suggestion\nasync def test_cors_headers_present_for_allowed_origin(client: httpx.AsyncClient) -> None:\n    \"\"\"Response includes access-control-allow-origin for the default allowed origin.\"\"\"\n    resp = await client.options(\n        \"/api/v1/health\",\n        headers={\n            \"origin\": \"http://localhost:3000\",\n            \"access-control-request-method\": \"GET\",\n        },\n    )\n    assert resp.status_code in {200, 204}\n    assert resp.headers.get(\"access-control-allow-origin\") == \"http://localhost:3000\"\n    assert resp.headers.get(\"access-control-allow-credentials\") == \"true\"\n```\n</issue_to_address>\n\n### Comment 2\n<location path=\"backend/tests/unit/test_health.py\" line_range=\"43-52\" />\n<code_context>\n+    assert resp.headers.get(\"access-control-allow-credentials\") == \"true\"\n+\n+\n+async def test_cors_rejects_disallowed_origin(client: httpx.AsyncClient) -> None:\n+    \"\"\"Response omits access-control-allow-origin for a non-allowed origin.\"\"\"\n+    resp = await client.options(\n+        \"/api/v1/health\",\n+        headers={\n+            \"origin\": \"http://evil.example.com\",\n+            \"access-control-request-method\": \"GET\",\n+        },\n+    )\n+    assert resp.headers.get(\"access-control-allow-origin\") != \"http://evil.example.com\"\n</code_context>\n<issue_to_address>\n**suggestion (testing):** Strengthen the disallowed-origin CORS test with an explicit status/header expectation\n\nThis test only asserts that the header is not the disallowed origin, which could still allow misleading values. Please also assert either that the header is absent (e.g. `assert \"access-control-allow-origin\" not in resp.headers`) or that the status code clearly indicates a blocked preflight, depending on the intended behavior.\n</issue_to_address>\n~~~\n\n</details>\n\n***\n\n<details>\n<summary>Sourcery is free for open source - if you like our reviews please consider sharing them ‚ú®</summary>\n\n- [X](https://twitter.com/intent/tweet?text=I%20just%20got%20an%20instant%20code%20review%20from%20%40SourceryAI%2C%20and%20it%20was%20brilliant%21%20It%27s%20free%20for%20open%20source%20and%20has%20a%20free%20trial%20for%20private%20code.%20Check%20it%20out%20https%3A//sourcery.ai)\n- [Mastodon](https://mastodon.social/share?text=I%20just%20got%20an%20instant%20code%20review%20from%20%40SourceryAI%2C%20and%20it%20was%20brilliant%21%20It%27s%20free%20for%20open%20source%20and%20has%20a%20free%20trial%20for%20private%20code.%20Check%20it%20out%20https%3A//sourcery.ai)\n- [LinkedIn](https://www.linkedin.com/sharing/share-offsite/?url=https://sourcery.ai)\n- [Facebook](https://www.facebook.com/sharer/sharer.php?u=https://sourcery.ai)\n\n</details>\n\n<sub>\nHelp me be more useful! Please click üëç or üëé on each comment and I'll use the feedback to improve your reviews.\n</sub>",
  "verdict": "ADDRESSED",
  "tests_checklist": [],
  "code_quality_checklist": [],
  "security_checklist": [],
  "architecture_checklist": [],
  "dry_yagni_checklist": [],
  "fail_fast_checklist": [],
  "defensive_checklist": [],
  "security_findings": [],
  "architecture_findings": [],
  "issues_found": [],
  "suggested_improvements": [],
  "next_steps": [],
  "reviewer": "sourcery-ai[bot]",
  "date": "2026-02-28T11:40:47Z",
  "commit_reference": "",
  "review_type": "external",
  "sequence_number": 1,
  "external_feedback": "Hey - I've found 2 issues, and left some high level feedback:\n\n- In `Settings.cors_origins_list`, returning `[\"\"]` when `CORS_ORIGINS` is an empty string can lead to a bogus allowed origin being configured; consider returning an empty list instead for the empty/whitespace-only case.\n- The `client` fixture in `test_health.py` creates an `httpx.AsyncClient` but never closes it; turning this into an async fixture that `await client.aclose()` in teardown will avoid potential resource warnings and better mirror real lifecycle usage.\n- As the project grows, keeping the router definition in `app/main.py` may become unwieldy; you might want to move the router (and the health endpoint) into the `app.api` package and have `main.py` just assemble the app and include routers.\n\n<details>\n<summary>Prompt for AI Agents</summary>\n\n~~~markdown\nPlease address the comments from this code review:\n\n## Overall Comments\n- In `Settings.cors_origins_list`, returning `[\"\"]` when `CORS_ORIGINS` is an empty string can lead to a bogus allowed origin being configured; consider returning an empty list instead for the empty/whitespace-only case.\n- The `client` fixture in `test_health.py` creates an `httpx.AsyncClient` but never closes it; turning this into an async fixture that `await client.aclose()` in teardown will avoid potential resource warnings and better mirror real lifecycle usage.\n- As the project grows, keeping the router definition in `app/main.py` may become unwieldy; you might want to move the router (and the health endpoint) into the `app.api` package and have `main.py` just assemble the app and include routers.\n\n## Individual Comments\n\n### Comment 1\n<location path=\"backend/tests/unit/test_health.py\" line_range=\"30-40\" />\n<code_context>\n+    assert \"authorization\" not in resp.request.headers\n+\n+\n+async def test_cors_headers_present_for_allowed_origin(client: httpx.AsyncClient) -> None:\n+    \"\"\"Response includes access-control-allow-origin for the default allowed origin.\"\"\"\n+    resp = await client.options(\n+        \"/api/v1/health\",\n+        headers={\n+            \"origin\": \"http://localhost:3000\",\n+            \"access-control-request-method\": \"GET\",\n+        },\n+    )\n+    assert resp.headers.get(\"access-control-allow-origin\") == \"http://localhost:3000\"\n+    assert resp.headers.get(\"access-control-allow-credentials\") == \"true\"\n+\n+\n</code_context>\n<issue_to_address>\n**suggestion (testing):** Add assertions on the CORS preflight response status code\n\nRight now this only checks the CORS headers. To better validate the preflight behavior, also assert the response status (FastAPI/Starlette typically returns 200 or 204), for example:\n\n```python\nassert resp.status_code in {200, 204}\n```\n\nThis would prevent a misconfigured middleware that returns an error status from still passing the test based solely on headers.\n\n```suggestion\nasync def test_cors_headers_present_for_allowed_origin(client: httpx.AsyncClient) -> None:\n    \"\"\"Response includes access-control-allow-origin for the default allowed origin.\"\"\"\n    resp = await client.options(\n        \"/api/v1/health\",\n        headers={\n            \"origin\": \"http://localhost:3000\",\n            \"access-control-request-method\": \"GET\",\n        },\n    )\n    assert resp.status_code in {200, 204}\n    assert resp.headers.get(\"access-control-allow-origin\") == \"http://localhost:3000\"\n    assert resp.headers.get(\"access-control-allow-credentials\") == \"true\"\n```\n</issue_to_address>\n\n### Comment 2\n<location path=\"backend/tests/unit/test_health.py\" line_range=\"43-52\" />\n<code_context>\n+    assert resp.headers.get(\"access-control-allow-credentials\") == \"true\"\n+\n+\n+async def test_cors_rejects_disallowed_origin(client: httpx.AsyncClient) -> None:\n+    \"\"\"Response omits access-control-allow-origin for a non-allowed origin.\"\"\"\n+    resp = await client.options(\n+        \"/api/v1/health\",\n+        headers={\n+            \"origin\": \"http://evil.example.com\",\n+            \"access-control-request-method\": \"GET\",\n+        },\n+    )\n+    assert resp.headers.get(\"access-control-allow-origin\") != \"http://evil.example.com\"\n</code_context>\n<issue_to_address>\n**suggestion (testing):** Strengthen the disallowed-origin CORS test with an explicit status/header expectation\n\nThis test only asserts that the header is not the disallowed origin, which could still allow misleading values. Please also assert either that the header is absent (e.g. `assert \"access-control-allow-origin\" not in resp.headers`) or that the status code clearly indicates a blocked preflight, depending on the intended behavior.\n</issue_to_address>\n~~~\n\n</details>\n\n***\n\n<details>\n<summary>Sourcery is free for open source - if you like our reviews please consider sharing them ‚ú®</summary>\n\n- [X](https://twitter.com/intent/tweet?text=I%20just%20got%20an%20instant%20code%20review%20from%20%40SourceryAI%2C%20and%20it%20was%20brilliant%21%20It%27s%20free%20for%20open%20source%20and%20has%20a%20free%20trial%20for%20private%20code.%20Check%20it%20out%20https%3A//sourcery.ai)\n- [Mastodon](https://mastodon.social/share?text=I%20just%20got%20an%20instant%20code%20review%20from%20%40SourceryAI%2C%20and%20it%20was%20brilliant%21%20It%27s%20free%20for%20open%20source%20and%20has%20a%20free%20trial%20for%20private%20code.%20Check%20it%20out%20https%3A//sourcery.ai)\n- [LinkedIn](https://www.linkedin.com/sharing/share-offsite/?url=https://sourcery.ai)\n- [Facebook](https://www.facebook.com/sharer/sharer.php?u=https://sourcery.ai)\n\n</details>\n\n<sub>\nHelp me be more useful! Please click üëç or üëé on each comment and I'll use the feedback to improve your reviews.\n</sub>",
  "code_comments": [
    {
      "body": "**suggestion (testing):** Add assertions on the CORS preflight response status code\n\nRight now this only checks the CORS headers. To better validate the preflight behavior, also assert the response status (FastAPI/Starlette typically returns 200 or 204), for example:\n\n```python\nassert resp.status_code in {200, 204}\n```\n\nThis would prevent a misconfigured middleware that returns an error status from still passing the test based solely on headers.\n\n```suggestion\nasync def test_cors_headers_present_for_allowed_origin(client: httpx.AsyncClient) -> None:\n    \"\"\"Response includes access-control-allow-origin for the default allowed origin.\"\"\"\n    resp = await client.options(\n        \"/api/v1/health\",\n        headers={\n            \"origin\": \"http://localhost:3000\",\n            \"access-control-request-method\": \"GET\",\n        },\n    )\n    assert resp.status_code in {200, 204}\n    assert resp.headers.get(\"access-control-allow-origin\") == \"http://localhost:3000\"\n    assert resp.headers.get(\"access-control-allow-credentials\") == \"true\"\n```",
      "path": "backend/tests/unit/test_health.py",
      "line": 40,
      "author": "sourcery-ai[bot]",
      "created_at": "2026-02-28T11:40:47Z",
      "id": null
    },
    {
      "body": "**suggestion (testing):** Strengthen the disallowed-origin CORS test with an explicit status/header expectation\n\nThis test only asserts that the header is not the disallowed origin, which could still allow misleading values. Please also assert either that the header is absent (e.g. `assert \"access-control-allow-origin\" not in resp.headers`) or that the status code clearly indicates a blocked preflight, depending on the intended behavior.",
      "path": "backend/tests/unit/test_health.py",
      "line": 52,
      "author": "sourcery-ai[bot]",
      "created_at": "2026-02-28T11:40:47Z",
      "id": null
    }
  ]
}