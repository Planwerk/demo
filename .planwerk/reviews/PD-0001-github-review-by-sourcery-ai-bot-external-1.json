{
  "feature_id": "PD-0001",
  "title": "GitHub review by sourcery-ai[bot]",
  "summary": "Hey - I've found 5 issues, and left some high level feedback:\n\n- The `get_db` signature currently uses `AsyncGenerator[AsyncSession]` from `collections.abc`, which is parameterized with two type arguments; consider tightening this to `AsyncGenerator[AsyncSession, None]` (or `AsyncIterator[AsyncSession]`) to keep strict mypy happy and reflect actual usage.\n- Right now `DATABASE_URL` is only implicitly constrained to `postgresql+asyncpg` (via defaults and tests); adding a small validator in `Settings` to enforce the asyncpg driver would surface misconfigurations earlier and keep the runtime behavior aligned with expectations.\n- Instantiating `settings = Settings()` at import time in `config.py` means importing `app.main` without `JWT_SECRET` set will raise immediately; if this is problematic for tooling or local commands, consider moving instantiation behind a helper (e.g., `get_settings()`) or deferring the strict check to application startup.\n\n<details>\n<summary>Prompt for AI Agents</summary>\n\n~~~markdown\nPlease address the comments from this code review:\n\n## Overall Comments\n- The `get_db` signature currently uses `AsyncGenerator[AsyncSession]` from `collections.abc`, which is parameterized with two type arguments; consider tightening this to `AsyncGenerator[AsyncSession, None]` (or `AsyncIterator[AsyncSession]`) to keep strict mypy happy and reflect actual usage.\n- Right now `DATABASE_URL` is only implicitly constrained to `postgresql+asyncpg` (via defaults and tests); adding a small validator in `Settings` to enforce the asyncpg driver would surface misconfigurations earlier and keep the runtime behavior aligned with expectations.\n- Instantiating `settings = Settings()` at import time in `config.py` means importing `app.main` without `JWT_SECRET` set will raise immediately; if this is problematic for tooling or local commands, consider moving instantiation behind a helper (e.g., `get_settings()`) or deferring the strict check to application startup.\n\n## Individual Comments\n\n### Comment 1\n<location path=\"backend/app/config.py\" line_range=\"20-23\" />\n<code_context>\n+    GITHUB_TOKEN: str | None = None\n+    LOG_LEVEL: str = \"INFO\"\n+\n+    @property\n+    def cors_origins_list(self) -> list[str]:\n+        \"\"\"Split comma-separated CORS_ORIGINS into a list.\"\"\"\n+        return [origin.strip() for origin in self.CORS_ORIGINS.split(\",\")]\n+\n+\n</code_context>\n<issue_to_address>\n**suggestion (bug_risk):** Filter out empty origins from `cors_origins_list` to avoid creating an invalid CORS origin.\n\nIf `CORS_ORIGINS` is empty or has trailing commas, this will add `\"\"` to the list, which FastAPI/Starlette treats as an invalid origin. Consider filtering out empty entries, e.g. `[o.strip() for o in self.CORS_ORIGINS.split(',') if o.strip()]`.\n\n```suggestion\n    @property\n    def cors_origins_list(self) -> list[str]:\n        \"\"\"Split comma-separated CORS_ORIGINS into a list, skipping empty entries.\"\"\"\n        return [origin.strip() for origin in self.CORS_ORIGINS.split(\",\") if origin.strip()]\n```\n</issue_to_address>\n\n### Comment 2\n<location path=\"backend/app/database.py\" line_range=\"19-22\" />\n<code_context>\n+    \"\"\"Base class for all ORM models.\"\"\"\n+\n+\n+async def get_db() -> AsyncGenerator[AsyncSession]:\n+    \"\"\"Yield an async database session, ensuring cleanup on completion.\"\"\"\n+    async with AsyncSessionLocal() as session:\n+        yield session\n</code_context>\n<issue_to_address>\n**suggestion:** Tighten the `AsyncGenerator` type annotation to be fully explicit for mypy strict mode.\n\n`AsyncGenerator` requires two type parameters under strict mypy: `AsyncGenerator[YieldType, SendType]`. Since you‚Äôre not sending values into the generator, use `AsyncGenerator[AsyncSession, None]`, or `AsyncIterator[AsyncSession]` if you don‚Äôt rely on `asend/athrow/aclose`.\n\nSuggested implementation:\n\n```python\nasync def get_db() -> AsyncGenerator[AsyncSession, None]:\n\n```\n\nTo make this type hint work under mypy strict mode, ensure that `AsyncGenerator` is imported with two type parameters available, e.g.:\n\n```python\nfrom typing import AsyncGenerator\n```\n\nor\n\n```python\nfrom collections.abc import AsyncGenerator\n```\n\nIf such an import is not already present in `backend/app/database.py`, add one alongside the other imports at the top of the file.\n</issue_to_address>\n\n### Comment 3\n<location path=\"backend/tests/unit/test_health.py\" line_range=\"10-14\" />\n<code_context>\n+from app.main import app\n+\n+\n+@pytest.fixture\n+def client() -> httpx.AsyncClient:\n+    \"\"\"Async test client against the FastAPI app.\"\"\"\n+    transport = ASGITransport(app=app)\n+    return httpx.AsyncClient(transport=transport, base_url=\"http://test\")\n+\n+\n</code_context>\n<issue_to_address>\n**suggestion (bug_risk):** Convert the client fixture to an async fixture and ensure the AsyncClient is properly closed\n\nThis fixture creates an `AsyncClient` but never closes it, which can leave open connections and cause flaky tests as the suite grows. Make it an async fixture that `yield`s the client and then calls `await client.aclose()` in teardown (e.g., via `@pytest_asyncio.fixture` or `pytest.fixture` with `async def`, depending on your pytest-asyncio setup).\n</issue_to_address>\n\n### Comment 4\n<location path=\"backend/tests/unit/test_health.py\" line_range=\"30-47\" />\n<code_context>\n+    assert resp.status_code == 200\n+\n+\n+async def test_cors_headers_present_for_allowed_origin(\n+    client: httpx.AsyncClient,\n+) -> None:\n+    \"\"\"CORS headers present for allowed origin on preflight.\"\"\"\n+    resp = await client.options(\n+        \"/api/v1/health\",\n+        headers={\n+            \"Origin\": \"http://localhost:3000\",\n+            \"Access-Control-Request-Method\": \"GET\",\n+        },\n+    )\n+    assert (\n+        resp.headers.get(\"access-control-allow-origin\")\n+        == \"http://localhost:3000\"\n+    )\n+    assert resp.headers.get(\"access-control-allow-credentials\") == \"true\"\n+\n+\n</code_context>\n<issue_to_address>\n**suggestion (testing):** Add a test that verifies CORS headers on a normal GET request, not just the preflight OPTIONS\n\nPlease also add an assertion for a simple `GET /api/v1/health` with an allowed `Origin` header to confirm the same CORS headers (`access-control-allow-origin` and, if applicable, `access-control-allow-credentials`) are present on non-preflight requests.\n\n```suggestion\nasync def test_cors_headers_present_for_allowed_origin(\n    client: httpx.AsyncClient,\n) -> None:\n    \"\"\"CORS headers present for allowed origin on preflight.\"\"\"\n    resp = await client.options(\n        \"/api/v1/health\",\n        headers={\n            \"Origin\": \"http://localhost:3000\",\n            \"Access-Control-Request-Method\": \"GET\",\n        },\n    )\n    assert (\n        resp.headers.get(\"access-control-allow-origin\")\n        == \"http://localhost:3000\"\n    )\n    assert resp.headers.get(\"access-control-allow-credentials\") == \"true\"\n\n\nasync def test_cors_headers_present_for_allowed_origin_on_get(\n    client: httpx.AsyncClient,\n) -> None:\n    \"\"\"CORS headers present for allowed origin on a normal GET request.\"\"\"\n    resp = await client.get(\n        \"/api/v1/health\",\n        headers={\n            \"Origin\": \"http://localhost:3000\",\n        },\n    )\n    assert (\n        resp.headers.get(\"access-control-allow-origin\")\n        == \"http://localhost:3000\"\n    )\n    assert resp.headers.get(\"access-control-allow-credentials\") == \"true\"\n```\n</issue_to_address>\n\n### Comment 5\n<location path=\"backend/tests/unit/test_database.py\" line_range=\"16-20\" />\n<code_context>\n+    assert issubclass(Base, DeclarativeBase)\n+\n+\n+def test_get_db_is_async_generator() -> None:\n+    \"\"\"get_db is an async generator function.\"\"\"\n+    from app.database import get_db\n+\n+    assert inspect.isasyncgenfunction(get_db)\n+\n+\n</code_context>\n<issue_to_address>\n**suggestion (testing):** Add an async test that actually consumes get_db and asserts it yields an AsyncSession instance\n\nThis only verifies that `get_db` is an async generator, not what it yields. Please add an async test (e.g. with `pytest.mark.asyncio`) that actually consumes the generator and asserts it yields an `AsyncSession`, e.g.:\n\n```python\n@pytest.mark.asyncio\nasync def test_get_db_yields_async_session():\n    from app.database import get_db, AsyncSession\n\n    agen = get_db()\n    session = await agen.__anext__()\n    assert isinstance(session, AsyncSession)\n    await agen.aclose()\n```\n\nThis keeps the test unit-level while verifying the contract of `get_db`.\n</issue_to_address>\n~~~\n\n</details>\n\n***\n\n<details>\n<summary>Sourcery is free for open source - if you like our reviews please consider sharing them ‚ú®</summary>\n\n- [X](https://twitter.com/intent/tweet?text=I%20just%20got%20an%20instant%20code%20review%20from%20%40SourceryAI%2C%20and%20it%20was%20brilliant%21%20It%27s%20free%20for%20open%20source%20and%20has%20a%20free%20trial%20for%20private%20code.%20Check%20it%20out%20https%3A//sourcery.ai)\n- [Mastodon](https://mastodon.social/share?text=I%20just%20got%20an%20instant%20code%20review%20from%20%40SourceryAI%2C%20and%20it%20was%20brilliant%21%20It%27s%20free%20for%20open%20source%20and%20has%20a%20free%20trial%20for%20private%20code.%20Check%20it%20out%20https%3A//sourcery.ai)\n- [LinkedIn](https://www.linkedin.com/sharing/share-offsite/?url=https://sourcery.ai)\n- [Facebook](https://www.facebook.com/sharer/sharer.php?u=https://sourcery.ai)\n\n</details>\n\n<sub>\nHelp me be more useful! Please click üëç or üëé on each comment and I'll use the feedback to improve your reviews.\n</sub>",
  "verdict": "COMMENT_ONLY",
  "tests_checklist": [],
  "code_quality_checklist": [],
  "security_checklist": [],
  "architecture_checklist": [],
  "dry_yagni_checklist": [],
  "fail_fast_checklist": [],
  "defensive_checklist": [],
  "security_findings": [],
  "architecture_findings": [],
  "issues_found": [],
  "suggested_improvements": [],
  "next_steps": [],
  "reviewer": "sourcery-ai[bot]",
  "date": "2026-02-27T07:51:01Z",
  "commit_reference": "3865520717",
  "review_type": "external",
  "sequence_number": 1,
  "external_feedback": "Hey - I've found 5 issues, and left some high level feedback:\n\n- The `get_db` signature currently uses `AsyncGenerator[AsyncSession]` from `collections.abc`, which is parameterized with two type arguments; consider tightening this to `AsyncGenerator[AsyncSession, None]` (or `AsyncIterator[AsyncSession]`) to keep strict mypy happy and reflect actual usage.\n- Right now `DATABASE_URL` is only implicitly constrained to `postgresql+asyncpg` (via defaults and tests); adding a small validator in `Settings` to enforce the asyncpg driver would surface misconfigurations earlier and keep the runtime behavior aligned with expectations.\n- Instantiating `settings = Settings()` at import time in `config.py` means importing `app.main` without `JWT_SECRET` set will raise immediately; if this is problematic for tooling or local commands, consider moving instantiation behind a helper (e.g., `get_settings()`) or deferring the strict check to application startup.\n\n<details>\n<summary>Prompt for AI Agents</summary>\n\n~~~markdown\nPlease address the comments from this code review:\n\n## Overall Comments\n- The `get_db` signature currently uses `AsyncGenerator[AsyncSession]` from `collections.abc`, which is parameterized with two type arguments; consider tightening this to `AsyncGenerator[AsyncSession, None]` (or `AsyncIterator[AsyncSession]`) to keep strict mypy happy and reflect actual usage.\n- Right now `DATABASE_URL` is only implicitly constrained to `postgresql+asyncpg` (via defaults and tests); adding a small validator in `Settings` to enforce the asyncpg driver would surface misconfigurations earlier and keep the runtime behavior aligned with expectations.\n- Instantiating `settings = Settings()` at import time in `config.py` means importing `app.main` without `JWT_SECRET` set will raise immediately; if this is problematic for tooling or local commands, consider moving instantiation behind a helper (e.g., `get_settings()`) or deferring the strict check to application startup.\n\n## Individual Comments\n\n### Comment 1\n<location path=\"backend/app/config.py\" line_range=\"20-23\" />\n<code_context>\n+    GITHUB_TOKEN: str | None = None\n+    LOG_LEVEL: str = \"INFO\"\n+\n+    @property\n+    def cors_origins_list(self) -> list[str]:\n+        \"\"\"Split comma-separated CORS_ORIGINS into a list.\"\"\"\n+        return [origin.strip() for origin in self.CORS_ORIGINS.split(\",\")]\n+\n+\n</code_context>\n<issue_to_address>\n**suggestion (bug_risk):** Filter out empty origins from `cors_origins_list` to avoid creating an invalid CORS origin.\n\nIf `CORS_ORIGINS` is empty or has trailing commas, this will add `\"\"` to the list, which FastAPI/Starlette treats as an invalid origin. Consider filtering out empty entries, e.g. `[o.strip() for o in self.CORS_ORIGINS.split(',') if o.strip()]`.\n\n```suggestion\n    @property\n    def cors_origins_list(self) -> list[str]:\n        \"\"\"Split comma-separated CORS_ORIGINS into a list, skipping empty entries.\"\"\"\n        return [origin.strip() for origin in self.CORS_ORIGINS.split(\",\") if origin.strip()]\n```\n</issue_to_address>\n\n### Comment 2\n<location path=\"backend/app/database.py\" line_range=\"19-22\" />\n<code_context>\n+    \"\"\"Base class for all ORM models.\"\"\"\n+\n+\n+async def get_db() -> AsyncGenerator[AsyncSession]:\n+    \"\"\"Yield an async database session, ensuring cleanup on completion.\"\"\"\n+    async with AsyncSessionLocal() as session:\n+        yield session\n</code_context>\n<issue_to_address>\n**suggestion:** Tighten the `AsyncGenerator` type annotation to be fully explicit for mypy strict mode.\n\n`AsyncGenerator` requires two type parameters under strict mypy: `AsyncGenerator[YieldType, SendType]`. Since you‚Äôre not sending values into the generator, use `AsyncGenerator[AsyncSession, None]`, or `AsyncIterator[AsyncSession]` if you don‚Äôt rely on `asend/athrow/aclose`.\n\nSuggested implementation:\n\n```python\nasync def get_db() -> AsyncGenerator[AsyncSession, None]:\n\n```\n\nTo make this type hint work under mypy strict mode, ensure that `AsyncGenerator` is imported with two type parameters available, e.g.:\n\n```python\nfrom typing import AsyncGenerator\n```\n\nor\n\n```python\nfrom collections.abc import AsyncGenerator\n```\n\nIf such an import is not already present in `backend/app/database.py`, add one alongside the other imports at the top of the file.\n</issue_to_address>\n\n### Comment 3\n<location path=\"backend/tests/unit/test_health.py\" line_range=\"10-14\" />\n<code_context>\n+from app.main import app\n+\n+\n+@pytest.fixture\n+def client() -> httpx.AsyncClient:\n+    \"\"\"Async test client against the FastAPI app.\"\"\"\n+    transport = ASGITransport(app=app)\n+    return httpx.AsyncClient(transport=transport, base_url=\"http://test\")\n+\n+\n</code_context>\n<issue_to_address>\n**suggestion (bug_risk):** Convert the client fixture to an async fixture and ensure the AsyncClient is properly closed\n\nThis fixture creates an `AsyncClient` but never closes it, which can leave open connections and cause flaky tests as the suite grows. Make it an async fixture that `yield`s the client and then calls `await client.aclose()` in teardown (e.g., via `@pytest_asyncio.fixture` or `pytest.fixture` with `async def`, depending on your pytest-asyncio setup).\n</issue_to_address>\n\n### Comment 4\n<location path=\"backend/tests/unit/test_health.py\" line_range=\"30-47\" />\n<code_context>\n+    assert resp.status_code == 200\n+\n+\n+async def test_cors_headers_present_for_allowed_origin(\n+    client: httpx.AsyncClient,\n+) -> None:\n+    \"\"\"CORS headers present for allowed origin on preflight.\"\"\"\n+    resp = await client.options(\n+        \"/api/v1/health\",\n+        headers={\n+            \"Origin\": \"http://localhost:3000\",\n+            \"Access-Control-Request-Method\": \"GET\",\n+        },\n+    )\n+    assert (\n+        resp.headers.get(\"access-control-allow-origin\")\n+        == \"http://localhost:3000\"\n+    )\n+    assert resp.headers.get(\"access-control-allow-credentials\") == \"true\"\n+\n+\n</code_context>\n<issue_to_address>\n**suggestion (testing):** Add a test that verifies CORS headers on a normal GET request, not just the preflight OPTIONS\n\nPlease also add an assertion for a simple `GET /api/v1/health` with an allowed `Origin` header to confirm the same CORS headers (`access-control-allow-origin` and, if applicable, `access-control-allow-credentials`) are present on non-preflight requests.\n\n```suggestion\nasync def test_cors_headers_present_for_allowed_origin(\n    client: httpx.AsyncClient,\n) -> None:\n    \"\"\"CORS headers present for allowed origin on preflight.\"\"\"\n    resp = await client.options(\n        \"/api/v1/health\",\n        headers={\n            \"Origin\": \"http://localhost:3000\",\n            \"Access-Control-Request-Method\": \"GET\",\n        },\n    )\n    assert (\n        resp.headers.get(\"access-control-allow-origin\")\n        == \"http://localhost:3000\"\n    )\n    assert resp.headers.get(\"access-control-allow-credentials\") == \"true\"\n\n\nasync def test_cors_headers_present_for_allowed_origin_on_get(\n    client: httpx.AsyncClient,\n) -> None:\n    \"\"\"CORS headers present for allowed origin on a normal GET request.\"\"\"\n    resp = await client.get(\n        \"/api/v1/health\",\n        headers={\n            \"Origin\": \"http://localhost:3000\",\n        },\n    )\n    assert (\n        resp.headers.get(\"access-control-allow-origin\")\n        == \"http://localhost:3000\"\n    )\n    assert resp.headers.get(\"access-control-allow-credentials\") == \"true\"\n```\n</issue_to_address>\n\n### Comment 5\n<location path=\"backend/tests/unit/test_database.py\" line_range=\"16-20\" />\n<code_context>\n+    assert issubclass(Base, DeclarativeBase)\n+\n+\n+def test_get_db_is_async_generator() -> None:\n+    \"\"\"get_db is an async generator function.\"\"\"\n+    from app.database import get_db\n+\n+    assert inspect.isasyncgenfunction(get_db)\n+\n+\n</code_context>\n<issue_to_address>\n**suggestion (testing):** Add an async test that actually consumes get_db and asserts it yields an AsyncSession instance\n\nThis only verifies that `get_db` is an async generator, not what it yields. Please add an async test (e.g. with `pytest.mark.asyncio`) that actually consumes the generator and asserts it yields an `AsyncSession`, e.g.:\n\n```python\n@pytest.mark.asyncio\nasync def test_get_db_yields_async_session():\n    from app.database import get_db, AsyncSession\n\n    agen = get_db()\n    session = await agen.__anext__()\n    assert isinstance(session, AsyncSession)\n    await agen.aclose()\n```\n\nThis keeps the test unit-level while verifying the contract of `get_db`.\n</issue_to_address>\n~~~\n\n</details>\n\n***\n\n<details>\n<summary>Sourcery is free for open source - if you like our reviews please consider sharing them ‚ú®</summary>\n\n- [X](https://twitter.com/intent/tweet?text=I%20just%20got%20an%20instant%20code%20review%20from%20%40SourceryAI%2C%20and%20it%20was%20brilliant%21%20It%27s%20free%20for%20open%20source%20and%20has%20a%20free%20trial%20for%20private%20code.%20Check%20it%20out%20https%3A//sourcery.ai)\n- [Mastodon](https://mastodon.social/share?text=I%20just%20got%20an%20instant%20code%20review%20from%20%40SourceryAI%2C%20and%20it%20was%20brilliant%21%20It%27s%20free%20for%20open%20source%20and%20has%20a%20free%20trial%20for%20private%20code.%20Check%20it%20out%20https%3A//sourcery.ai)\n- [LinkedIn](https://www.linkedin.com/sharing/share-offsite/?url=https://sourcery.ai)\n- [Facebook](https://www.facebook.com/sharer/sharer.php?u=https://sourcery.ai)\n\n</details>\n\n<sub>\nHelp me be more useful! Please click üëç or üëé on each comment and I'll use the feedback to improve your reviews.\n</sub>\n\n## Inline Comments\n- `backend/app/config.py:23` ‚Äî \"**suggestion (bug_risk):** Filter out empty origins from `cors_origins_list` to avoid creating an invalid CORS origin.\n\nIf `CORS_ORIGINS` is empty or has trailing commas, this will add `\"\"` to the list, which FastAPI/Starlette treats as an invalid origin. Consider filtering out empty entries, e.g. `[o.strip() for o in self.CORS_ORIGINS.split(',') if o.strip()]`.\n\n```suggestion\n    @property\n    def cors_origins_list(self) -> list[str]:\n        \"\"\"Split comma-separated CORS_ORIGINS into a list, skipping empty entries.\"\"\"\n        return [origin.strip() for origin in self.CORS_ORIGINS.split(\",\") if origin.strip()]\n```\"\n- `backend/app/database.py:22` ‚Äî \"**suggestion:** Tighten the `AsyncGenerator` type annotation to be fully explicit for mypy strict mode.\n\n`AsyncGenerator` requires two type parameters under strict mypy: `AsyncGenerator[YieldType, SendType]`. Since you‚Äôre not sending values into the generator, use `AsyncGenerator[AsyncSession, None]`, or `AsyncIterator[AsyncSession]` if you don‚Äôt rely on `asend/athrow/aclose`.\n\nSuggested implementation:\n\n```python\nasync def get_db() -> AsyncGenerator[AsyncSession, None]:\n\n```\n\nTo make this type hint work under mypy strict mode, ensure that `AsyncGenerator` is imported with two type parameters available, e.g.:\n\n```python\nfrom typing import AsyncGenerator\n```\n\nor\n\n```python\nfrom collections.abc import AsyncGenerator\n```\n\nIf such an import is not already present in `backend/app/database.py`, add one alongside the other imports at the top of the file.\"\n- `backend/tests/unit/test_health.py:14` ‚Äî \"**suggestion (bug_risk):** Convert the client fixture to an async fixture and ensure the AsyncClient is properly closed\n\nThis fixture creates an `AsyncClient` but never closes it, which can leave open connections and cause flaky tests as the suite grows. Make it an async fixture that `yield`s the client and then calls `await client.aclose()` in teardown (e.g., via `@pytest_asyncio.fixture` or `pytest.fixture` with `async def`, depending on your pytest-asyncio setup).\"\n- `backend/tests/unit/test_health.py:47` ‚Äî \"**suggestion (testing):** Add a test that verifies CORS headers on a normal GET request, not just the preflight OPTIONS\n\nPlease also add an assertion for a simple `GET /api/v1/health` with an allowed `Origin` header to confirm the same CORS headers (`access-control-allow-origin` and, if applicable, `access-control-allow-credentials`) are present on non-preflight requests.\n\n```suggestion\nasync def test_cors_headers_present_for_allowed_origin(\n    client: httpx.AsyncClient,\n) -> None:\n    \"\"\"CORS headers present for allowed origin on preflight.\"\"\"\n    resp = await client.options(\n        \"/api/v1/health\",\n        headers={\n            \"Origin\": \"http://localhost:3000\",\n            \"Access-Control-Request-Method\": \"GET\",\n        },\n    )\n    assert (\n        resp.headers.get(\"access-control-allow-origin\")\n        == \"http://localhost:3000\"\n    )\n    assert resp.headers.get(\"access-control-allow-credentials\") == \"true\"\n\n\nasync def test_cors_headers_present_for_allowed_origin_on_get(\n    client: httpx.AsyncClient,\n) -> None:\n    \"\"\"CORS headers present for allowed origin on a normal GET request.\"\"\"\n    resp = await client.get(\n        \"/api/v1/health\",\n        headers={\n            \"Origin\": \"http://localhost:3000\",\n        },\n    )\n    assert (\n        resp.headers.get(\"access-control-allow-origin\")\n        == \"http://localhost:3000\"\n    )\n    assert resp.headers.get(\"access-control-allow-credentials\") == \"true\"\n```\"\n- `backend/tests/unit/test_database.py:20` ‚Äî \"**suggestion (testing):** Add an async test that actually consumes get_db and asserts it yields an AsyncSession instance\n\nThis only verifies that `get_db` is an async generator, not what it yields. Please add an async test (e.g. with `pytest.mark.asyncio`) that actually consumes the generator and asserts it yields an `AsyncSession`, e.g.:\n\n```python\n@pytest.mark.asyncio\nasync def test_get_db_yields_async_session():\n    from app.database import get_db, AsyncSession\n\n    agen = get_db()\n    session = await agen.__anext__()\n    assert isinstance(session, AsyncSession)\n    await agen.aclose()\n```\n\nThis keeps the test unit-level while verifying the contract of `get_db`.\"",
  "resolved": true
}