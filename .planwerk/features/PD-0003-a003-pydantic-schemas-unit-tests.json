{
  "feature_id": "PD-0003",
  "title": "A003: Pydantic Schemas & Unit Tests",
  "slug": "a003-pydantic-schemas-unit-tests",
  "status": "proposed",
  "phase": null,
  "summary": "",
  "description": "**Size:** ðŸ”¨ medium\n**Category:** backend\n**Priority:** high\n\n## Summary\n\nDefine Pydantic v2 request/response schemas for user registration (`UserCreate`), status posting (`StatusCreate`), authentication (`TokenResponse`), and paginated status listing (`PaginatedStatusResponse`). Establish `tests/conftest.py` shared fixtures and `tests/unit/test_schemas.py` for schema validation. These schemas form the contract layer between API routes and the ORM models already in place (`User`, `StatusUpdate`).\n\n## Scope\n\n**Included:**\n- `app/schemas/user.py` â€” `UserCreate` (registration input) and `UserRead` (safe output without `password_hash`)\n- `app/schemas/status.py` â€” `StatusCreate` (post input), `StatusRead` (single status output with nested user), `PaginatedStatusResponse` (cursor-based paginated list wrapper)\n- `app/schemas/token.py` â€” `TokenResponse` (JWT access + refresh tokens)\n- `app/schemas/__init__.py` â€” re-exports\n- `tests/conftest.py` â€” extend with schema-level fixtures (valid/invalid payloads)\n- `tests/unit/test_schemas.py` â€” validation rules: required fields, string constraints, email format, category literal, cursor pagination bounds\n\n**Excluded (YAGNI):**\n- `UserUpdate` / `UserPatch` schemas â€” no profile-edit endpoint yet\n- `StatusUpdate` (edit) schema â€” CRUD edit not in current scope\n- `avatar_url` on `UserCreate` â€” avatar upload is a profile-edit concern\n- Password strength validation beyond non-empty â€” decided as out of scope\n- GitHub link schemas â€” separate feature per README\n- Gamification schemas â€” separate feature per README\n- WebSocket message schemas â€” separate concern\n\n## Visualization\n\n```mermaid\nflowchart LR\n    subgraph Schemas[\"app/schemas\"]\n        UC[\"UserCreate\"]\n        UR[\"UserRead\"]\n        SC[\"StatusCreate\"]\n        SR[\"StatusRead\"]\n        PSR[\"PaginatedStatusResponse\"]\n        TR[\"TokenResponse\"]\n    end\n\n    subgraph Models[\"app/models\"]\n        UM[\"User ORM\"]\n        SM[\"StatusUpdate ORM\"]\n    end\n\n    subgraph Tests[\"tests/unit\"]\n        TS[\"test_schemas.py\"]\n        CF[\"conftest.py fixtures\"]\n    end\n\n    UC -->|\"validates input for\"| UM\n    UR -->|\"serializes from\"| UM\n    SC -->|\"validates input for\"| SM\n    SR -->|\"serializes from\"| SM\n    PSR -->|\"wraps list of\"| SR\n    TR -->|\"returned by\"| AUTH[\"auth endpoints\"]\n\n    CF -->|\"provides payloads to\"| TS\n    TS -->|\"validates\"| Schemas\n```\n\n```mermaid\nsequenceDiagram\n    participant C as Client\n    participant API as API Route\n    participant S as Schema\n    participant M as ORM Model\n\n    C->>API: POST /auth/register\n    API->>S: validate UserCreate\n    S-->>API: validated data\n    API->>M: create User row\n    M-->>API: User instance\n    API->>S: serialize to UserRead\n    S-->>API: safe response\n    API-->>C: 201 + UserRead\n\n    C->>API: POST /status\n    API->>S: validate StatusCreate\n    S-->>API: validated data\n    API->>M: create StatusUpdate row\n    API-->>C: 201 + StatusRead\n\n    C->>API: GET /status?limit=20&after=cursor\n    API->>M: query StatusUpdate rows\n    API->>S: wrap in PaginatedStatusResponse\n    API-->>C: 200 + PaginatedStatusResponse\n```\n\n## Key Components\n\n- **`UserCreate`** (`app/schemas/user.py`): `username` (3â€“50 chars, alphanumeric+underscore), `display_name` (1â€“100 chars), `email` (valid format, max 255), `password` (non-empty string). Maps to `User` model fields. No `avatar_url` â€” YAGNI for registration.\n- **`UserRead`** (`app/schemas/user.py`): `id` (UUID), `username`, `display_name`, `email`, `avatar_url`, `xp`, `current_streak`, `created_at`. Excludes `password_hash`. Uses `model_config = ConfigDict(from_attributes=True)`.\n- **`StatusCreate`** (`app/schemas/status.py`): `message` (1â€“2000 chars, stripped), `category` (required `Literal[\"done\", \"in-progress\", \"blocked\", \"planning\"]` â€” matches `VALID_CATEGORIES` from ORM model).\n- **`StatusRead`** (`app/schemas/status.py`): `id`, `message`, `category`, `created_at`, `user` (nested `UserRead`). `from_attributes=True`.\n- **`PaginatedStatusResponse`** (`app/schemas/status.py`): Cursor-based â€” `items` (list of `StatusRead`), `next_cursor` (optional str, opaque token for next page), `has_more` (bool), `limit` (int).\n- **`TokenResponse`** (`app/schemas/token.py`): `access_token` (str), `refresh_token` (str), `token_type` (literal `\"bearer\"`).\n- **`tests/conftest.py`**: Add fixtures for valid `UserCreate`/`StatusCreate` dicts and factory helpers.\n- **`tests/unit/test_schemas.py`**: Test valid construction, field constraints (too short/long, invalid email, invalid category, empty password), and `from_attributes` round-tripping from ORM model mocks.",
  "stories": [],
  "requirements": [],
  "tasks": [],
  "test_specifications": [],
  "affected_files": [],
  "similar_patterns": [],
  "review_criteria": [],
  "implementation_notes": "",
  "status_history": {
    "draft": {
      "github_account": "berendt",
      "timestamp": "2026-02-24T19:10:35.695436"
    },
    "elaborated": {
      "github_account": "berendt",
      "timestamp": "2026-03-01T09:20:20.370852"
    }
  },
  "origin": "plan",
  "devils_advocate_report": {
    "verdict": "PROCEED",
    "summary": "This is a well-scoped, necessary schema layer that correctly bridges existing ORM models to future API routes. The YAGNI exclusions are disciplined. However, there are several design decisions worth challenging â€” most notably around duplicated validation logic, the cursor pagination design being premature, and whether the test strategy covers the right surface area. None are blocking, but three deserve reconsideration.",
    "challenges": [
      {
        "claim": "Category validation should live in both the Pydantic schema (Literal type) and the ORM model (@validates decorator)",
        "counter_argument": "This creates duplicated validation logic in two layers. The ORM model already validates category via `@validates(\"category\")` against `VALID_CATEGORIES`. Adding a `Literal[\"done\", \"in-progress\", \"blocked\", \"planning\"]` in `StatusCreate` means the category list is hardcoded in two places. When categories change (and they will â€” \"review\", \"shipped\" are obvious candidates), both must be updated in lockstep or they'll silently diverge. The spec mentions matching `VALID_CATEGORIES` from the ORM model but doesn't propose importing or sharing the source of truth.",
        "risk_level": "medium",
        "alternative": "Define the canonical category list once â€” either as a `StrEnum` in a shared `app/types.py` or keep `VALID_CATEGORIES` in the ORM module and derive the Pydantic Literal from it. Pydantic v2 supports `Annotated[str, Field(pattern=...)]` or you can use `Literal[*VALID_CATEGORIES]` (Python 3.12 supports this with type aliasing). This keeps a single source of truth. Trade-off: slightly more indirection, but eliminates a real maintenance footgun."
      },
      {
        "claim": "Cursor-based PaginatedStatusResponse is the right pagination approach to define now",
        "counter_argument": "No API route exists yet. No query logic exists. The cursor format is described as \"opaque token\" but the schema doesn't constrain or define it â€” it's just `Optional[str]`. This means the schema provides zero validation value for the cursor itself. The pagination design is being locked in before any consumer exists. Cursor-based pagination is correct for infinite-scroll feeds, but offset-based might be simpler for an MVP that will initially have few users. More importantly, defining the pagination wrapper now without the route means you're speculating about the response shape â€” will there be a `total_count`? Will the cursor be base64-encoded? These decisions are better made when implementing the actual endpoint.",
        "risk_level": "medium",
        "alternative": "Option A: Ship `PaginatedStatusResponse` but mark it as provisional â€” accept that it will likely change when the route is built. Option B: Defer the pagination schema to the status-listing endpoint feature and only define `StatusRead` now. Trade-off: Option A risks rework but establishes the pattern early; Option B follows YAGNI more strictly but leaves the schema package incomplete relative to the spec."
      },
      {
        "claim": "UserRead should include `email` in the response schema",
        "counter_argument": "The spec includes `email` in `UserRead`. But `StatusRead` nests `UserRead` â€” meaning every status update in a paginated feed would expose every author's email address. This is a privacy concern. Most social platforms do not expose emails in public-facing responses. If the feed endpoint is unauthenticated or shows statuses from other users, you're leaking PII. The ORM model has `email` because the database needs it; the read schema shouldn't blindly mirror every non-secret column.",
        "risk_level": "high",
        "alternative": "Split into `UserRead` (for the authenticated user's own profile, includes email) and `UserPublic` (for nested/public contexts, excludes email). `StatusRead` nests `UserPublic`. Trade-off: one more schema, but prevents a real privacy issue. Alternatively, keep `UserRead` as-is but document that the status feed endpoint must use a separate `UserSummary` projection â€” but this defers the fix to a future feature where it's easy to forget."
      },
      {
        "claim": "The test strategy â€” testing Pydantic schemas in isolation with mock ORM objects â€” provides meaningful value",
        "counter_argument": "Pydantic v2 schemas are largely declarative. Testing that `Field(min_length=3, max_length=50)` rejects a 2-character string is testing Pydantic itself, not your application logic. The `from_attributes=True` round-trip test with mock objects is the only test that validates something non-trivial (the field mapping between ORM and schema). The constraint tests have value as regression guards if someone changes a field type, but they're thin. The real schema bugs you'll hit in production â€” missing fields when the ORM model evolves, serialization of lazy-loaded relationships, datetime timezone handling â€” won't be caught by unit tests against mock objects.",
        "risk_level": "low",
        "alternative": "Keep the tests but shift the emphasis: (1) prioritize `from_attributes` round-trip tests that use realistic ORM-shaped objects with all fields populated, (2) add a test that constructs `StatusRead` with a nested `UserRead` to verify the nesting works with `from_attributes`, (3) skip testing individual constraint boundaries (Pydantic's own test suite covers that) and focus on your custom validators. Trade-off: fewer tests but higher signal-to-noise ratio."
      },
      {
        "claim": "message field should be stripped (whitespace-trimmed) in StatusCreate",
        "counter_argument": "This is fine as a general principle, but the spec says \"1â€“2000 chars, stripped\" â€” does the length check apply before or after stripping? A message of 2001 spaces would strip to empty and fail the min_length check, which is correct. But a message of \"  hello  \" (9 chars) strips to \"hello\" (5 chars) â€” is the length constraint against the stripped or raw value? In Pydantic v2, if you use a `@field_validator` to strip, it runs before `Field(min_length=...)` only if ordered correctly. Using `BeforeValidator` vs `AfterValidator` matters. This is an implementation detail, but the spec doesn't clarify it, and getting it wrong means either accepting whitespace-only messages or rejecting messages that are valid after stripping.",
        "risk_level": "low",
        "alternative": "Use `Annotated[str, BeforeValidator(str.strip), Field(min_length=1, max_length=2000)]` to ensure stripping happens before length validation. Document this in a code comment. Test explicitly: whitespace-only input should be rejected, input with leading/trailing whitespace should be accepted if the trimmed result is within bounds."
      },
      {
        "claim": "pydantic is not an explicit dependency â€” it's transitively available via pydantic-settings",
        "counter_argument": "Looking at pyproject.toml, `pydantic` is not listed as a direct dependency. It's pulled in transitively by `pydantic-settings>=2.0`. This feature creates substantial Pydantic schema code â€” it becomes a core dependency. Relying on transitive availability means a future refactor that removes `pydantic-settings` (e.g., switching to a different config library) could break the schemas. The mypy config already references `pydantic.mypy` plugin, reinforcing that pydantic is a first-class dependency.",
        "risk_level": "low",
        "alternative": "Add `pydantic>=2.0` as an explicit dependency in pyproject.toml alongside this feature. Cost: one line. Benefit: explicit dependency declaration, pip resolver won't drop it unexpectedly."
      },
      {
        "claim": "TokenResponse with access_token + refresh_token is the right auth schema to define now",
        "counter_argument": "No auth implementation exists yet. The JWT strategy (access + refresh tokens) is being baked into the schema contract before the auth feature is designed. What if the auth feature uses HTTP-only cookies for the refresh token (a security best practice)? Then `refresh_token` wouldn't appear in the JSON response body at all. What if the auth feature adds `expires_in` (standard OAuth2 practice)? The schema would need to change. Defining this now creates a commitment with zero consumers.",
        "risk_level": "medium",
        "alternative": "Option A: Define only `TokenResponse` with `access_token` and `token_type` (the OAuth2-standard minimum), leaving refresh token handling to the auth feature. Option B: Defer `TokenResponse` entirely to the auth feature. Trade-off: Option A gives the auth feature a stable starting point; Option B is purer YAGNI but leaves the schemas package without its token type."
      }
    ],
    "risk_flags": [
      "PRIVACY: UserRead exposes email in nested StatusRead contexts. If the status feed is public or shows other users' statuses, this leaks email addresses of all users. This should be resolved before the API routes are built â€” retrofitting a UserPublic schema later risks forgetting to update existing endpoints.",
      "DUAL VALIDATION: Category values hardcoded in both Literal type and ORM @validates without a shared source of truth. First category change will cause a bug if only one is updated."
    ],
    "alternatives": [
      "**Shared enum for categories**: Create `app/types.py` with `class StatusCategory(StrEnum): DONE = \"done\"; IN_PROGRESS = \"in-progress\"; BLOCKED = \"blocked\"; PLANNING = \"planning\"`. Use it in both the ORM model and Pydantic schema. Trade-off: one more file, but eliminates duplication across the validation boundary.",
      "**Split UserRead/UserPublic**: `UserPublic` (id, username, display_name, avatar_url) for nesting in public responses like StatusRead. `UserRead` (extends UserPublic with email, xp, current_streak, created_at) for authenticated \"my profile\" endpoints. Trade-off: two schemas instead of one, but correct privacy boundary from day one.",
      "**Defer pagination + token schemas**: Only define UserCreate, UserRead, UserPublic, StatusCreate, StatusRead now. Defer PaginatedStatusResponse to the feed endpoint feature, TokenResponse to the auth feature. Trade-off: smaller deliverable, stricter YAGNI, but the schemas package would be incomplete relative to the original spec."
    ]
  }
}